-- 2021-01-04 DBMS_10. VIEW, INLINE VIEW, TOP-N   ⓒcherryuki(ji)
-- [X] VIEW, INLINE VIEW, TOP-N
-- 1) VIEW: 가상의 테이블 (1)단순뷰, (2)복합뷰
-- (1) 단순뷰; 하나의 테이블로 구성된 뷰
-- 'EMPV0'라는 VIEW 생성 또는 수정(대체) = EMP테이블 일부 필드를 갖는 가상의 테이블
CREATE OR REPLACE VIEW EMPV0
    AS SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP;
SELECT * FROM EMPV0;
INSERT INTO EMPV0 VALUES(1111, 'KONG', 'IT', 40); --VIEW에 INSERT하면 EMP테이블에도 INSERT 됨
SELECT * FROM EMP;
UPDATE EMPV0 SET JOB='ANALYST' WHERE EMPNO=1111;
SELECT * FROM EMP WHERE EMPNO=1111;
DELETE FROM EMPV0 WHERE EMPNO=1111;
-- 'EMPV0'라는 VIEW = EMP의 30번 부서행만
CREATE OR REPLACE VIEW EMPV0
    AS SELECT * FROM EMP WHERE DEPTNO=30;
SELECT * FROM USER_VIEWS; --데이터 딕셔너리뷰를 확인
SELECT * FROM EMPV0;
DESC EMPV0;
INSERT INTO EMPV0 VALUES (1111, 'KONG', NULL, NULL, NULL, NULL, NULL, 30);
SELECT * FROM EMP;
-- 40번 부서 입력도 가능하나 EMPV0에서는 보이지 않음
INSERT INTO EMPV0 VALUES (1112, 'KONG', NULL, NULL, NULL, NULL, NULL, 40);
SELECT * FROM EMPV0; -- 1111(30부서만)
SELECT * FROM EMP; -- 1111, 1112
DELETE FROM EMPV0 WHERE EMPNO<1113; -- 30번 부서만 삭제 됨
DELETE FROM EMP WHERE EMPNO<1113;
COMMIT;
-- EMP 테이블 30번 부서의 가상 테이블(30번 부서만 INSERT 가능)
CREATE OR REPLACE VIEW EMPV0
    AS SELECT * FROM EMP WHERE DEPTNO=30
    WITH CHECK OPTION; -- VIEW의 제한 조건
SELECT * FROM EMPV0;
INSERT INTO EMPV0 VALUES (1111, 'KONG', NULL, NULL, NULL, NULL, NULL, 30);
DELETE FROM EMPV0 WHERE EMPNO=1111;
-- WITH CHECK OPTHION 제한 조건으로 30번 부서만 INSERT 가능
-- (2) 복합뷰; 하나 이상의 테이블
CREATE OR REPLACE VIEW EMPV1
    AS SELECT EMPNO, ENAME, JOB, DNAME FROM EMP E, DEPT D
        WHERE E.DEPTNO=D.DEPTNO;
SELECT * FROM EMPV1;
INSERT INTO EMPV1 VALUES (1110, 'KONG', 'SALESMAN', 'RESEARCH'); -- 불가능
-- 복합뷰 포함 DML명령어를 모두 사용할 수 없는 경우(INSERT, UPDATE, DELETE 불가) - ONLY SELECT 가능
CREATE OR REPLACE VIEW EMPV2
    AS SELECT EMPNO, ENAME, DEPTNO FROM EMP
    WITH READ ONLY; -- 읽기 전용 VIEW
SELECT * FROM EMPV2;
SELECT EMPNO, ENAME, DNAME FROM EMPV2 E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO;
INSERT INTO EMPV2 VALUES(1111, 'KONG', 40); --READ ONLY VIEW이므로 수정 불가능
-- EMP 테이블로부터 사번, 이름, 급여
CREATE OR REPLACE VIEW EMPV3
    AS SELECT ENAME, SAL FROM EMP;
SELECT * FROM EMPV3;
INSERT INTO EMPV3 VALUES('KONG', NULL); -- PRIMARY KEY(EMPNO)가 NOT NULL이므로 INSERT 불가
SELECT * FROM EMP;
DESC EMPV3;
CREATE OR REPLACE VIEW EMPV3
    AS SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP;
INSERT INTO EMPV3 VALUES (1112, 'KONG', 3500, NULL);
INSERT INTO EMPV3 VALUES (1113, 'KONG', 3500, 50); -- DEPT테이블에 DEPTNO 50(PARENT KEY) 없어서 INSERT 불가능
SELECT * FROM EMPV3;
-- 서브쿼리의 칼럼명에 특수문자가 있을 경우 별칭 설정 필요! 
-- ① 칼럼에 직접 ALIAS(별칭) 설정
CREATE OR REPLACE VIEW EMPV3
    AS SELECT EMPNO, ENAME, SAL*12 SAL12 FROM EMP; -- 칼럼에 별명 붙여야 함(본 칼럼명에 특수문자 사용 불가)
-- ② ALIAS(별칭)을 테이블 옆에 따로 설정
CREATE OR REPLACE VIEW EMPV3 (EMPNO, NAME, YEARSAL)
    AS SELECT EMPNO, ENAME, SAL*12 FROM EMP;
SELECT * FROM EMPV3;
-- VEIW 생성시 필드에 연산이나 함수 사용한 경우 INSERT 불가; YEARSAL(SAL*12)가 가상 칼럼이므로 INSERT 불가능
INSERT INTO EMPV3 VALUES(1115, 'KONG', 12000); --불가능
-- VIEW 생성시 필드에 함수를 사용한 경우 INERT 불가
-- EMP (사번, 이름, 반올림한 SAL)
CREATE OR REPLACE VIEW EMPV3 (EMPNO, ENAME, SAL)
    AS SELECT EMPNO, ENAME, ROUND(SAL, -3) FROM EMP;
SELECT * FROM EMPV3;
INSERT INTO EMPV3 VALUES (1115, 'KONG', 1000); --불가능
-- 부서번호, 부서별 최소급여, 최대급여, 평균급여를 포함한 DEPTV1뷰 생성
CREATE OR REPLACE VIEW DEPTV1
    AS SELECT DEPTNO, MIN(SAL) MINSAL, MAX(SAL) MAXSAL, ROUND(AVG(SAL), 1) AVGSAL FROM EMP GROUP BY DEPTNO;
SELECT * FROM DEPTV1;
-- 부서번호, 부서명, 부서별 최소급여, 최대급여, 평균급여 -- SELECT는 제한없이 사용 가능 BUT 함수 있으므로 INSERT 불가능
SELECT D.DEPTNO, DNAME, MINSAL, MAXSAL, ROUND(AVGSAL) FROM DEPTV1 V, DEPT D
    WHERE V.DEPTNO=D.DEPTNO;
SELECT * FROM DEPTV1;
SELECT * FROM EMP WHERE EMPNO<1113;
DELETE FROM EMP WHERE EMPNO<1113;
SELECT * FROM EMP;
-- EMP(중복이 제거된 JOB, DEPTNO)
SELECT DISTINCT JOB, DEPTNO FROM EMP ORDER BY JOB; --서브쿼리
CREATE OR REPLACE VIEW EMPV3
    AS SELECT DISTINCT JOB, DEPTNO FROM EMP ORDER BY JOB;
SELECT * FROM EMPV3;
INSERT INTO EMPV3 VALUES ('CLERK', 10); --불가능

2) INLINE VIEW: SQL문 수행하는 한 줄의 명령문에서만 유효한 뷰(FROM절 서브쿼리)
-- SELECT 필드1, 필드2, ...
--  FROM 테이블1, (서브쿼리) S
--  WHERE 조건
-- 급여가 2000을 초과하는 사원의 평균
SELECT AVG(SAL) FROM EMP WHERE SAL>2000;
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL>2000);
-- 이름, 급여, 부서번호, 해당사원의 부서 평균 급여
SELECT ENAME, SAL, DEPTNO, (SELECT ROUND(AVG(SAL)) FROM EMP WHERE DEPTNO=E.DEPTNO) DEPTNO_AVG_SAL
    FROM EMP E;
-- 이름, 급여, 부서번호, 해당 사원의 부서 평균 급여(INLINE VIEW 사용)
SELECT ENAME, SAL, DEPTNO FROM EMP; -- (1)
SELECT DEPTNO, ROUND(AVG(SAL)) FROM EMP GROUP BY DEPTNO; -- (2)
SELECT ENAME, SAL, E.DEPTNO, S.AVGSAL
    FROM EMP E, (SELECT DEPTNO, ROUND(AVG(SAL)) AVGSAL FROM EMP GROUP BY DEPTNO) S
    WHERE E.DEPTNO=S.DEPTNO;
-- 이름, 급여, 부서번호, 해당 사원의 부서 평균 급여 (부서평균보다 많이 받는 사원만 출력)
SELECT ENAME, SAL, E.DEPTNO, S.AVGSAL 
    FROM EMP E, (SELECT DEPTNO, ROUND(AVG(SAL)) AVGSAL FROM EMP GROUP BY DEPTNO) S
    WHERE E.DEPTNO=S.DEPTNO AND SAL>S.AVGSAL;
    
-- 3) ★ TOP-N 구문(TOP 1~10EMD, 11~20등) -- 페이징 처리
-- ROWNUM: 테이블에서 가져온 순서. 테이블에서 행의 논리적인 출력 순서
SELECT ROWNUM, ENAME, SAL FROM EMP;
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL; 
--SELECT문 먼저 실행 후 ORDER BY 실행해서 출력하므로 ROWNUM번호와 SAL 오름차순 순서 다름
SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL);
SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL)
    WHERE ROWNUM<6; -- TOP 1~5등 출력
SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL)
    WHERE ROWNUM BETWEEN 6 AND 10; -- 출력 불가(FROM->WHERE>SELECT 순서로 수행되므로 전부 거짓처리 되어 데이터 출력X)
-- 함수를 이용한 RANK 출력
SELECT RANK() OVER(ORDER BY SAL) RANK,
       DENSE_RANK() OVER(ORDER BY SAL) DENSE_RANK,
       ROW_NUMBER() OVER(ORDER BY SAL) ROW_NUMBER,
       ENAME, SAL FROM EMP;
-- TOP-N구문
SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL); -- 서브쿼리
SELECT RN, ENAME, SAL 
    FROM (SELECT ROWNUM RN, ENAME, SAL -- 서브쿼리 ROWNUM에 반드시 별칭 필요, SELECT문&WHERE절에서 해당 별칭 사용 必
            FROM (SELECT * FROM EMP ORDER BY SAL))
    WHERE RN BETWEEN 6 AND 10; -- TOP-N 구문
SELECT RN, ENAME, SAL
    FROM (SELECT ROWNUM RN, ENAME, SAL
            FROM (SELECT * FROM EMP ORDER BY SAL DESC))
    WHERE RN BETWEEN 1 AND 5;
-- 이름 알파벳 순서대로 6~10등까지 출력(이름, 사번, JOB, MGR, HIREDATE)
SELECT ENAME, EMPNO, JOB, MGR, HIREDATE 
    FROM (SELECT ROWNUM RN, ENAME, EMPNO, JOB, MGR, HIREDATE
            FROM (SELECT * FROM EMP ORDER BY ENAME))
    WHERE RN BETWEEN 6 AND 10;

-- <총 연습문제>
-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
    AS SELECT DNAME, ENAME FROM DEPT D, EMP E
        WHERE D.DEPTNO=E.DEPTNO;
SELECT * FROM DNAME_ENAME_VU;
-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰,  WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU
    AS SELECT W.ENAME, M.ENAME MGRNAME FROM EMP W, EMP M WHERE W.MGR=M.EMPNO;
SELECT * FROM WORKER_MANAGER_VU;
-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수) ? 친구출제
SELECT DEPTNO, SUM_SAL, ROWNUM RN
    FROM (SELECT DEPTNO, SUM(SAL) SUM_SAL FROM EMP GROUP BY DEPTNO ORDER BY SUM_SAL DESC);
-- 3-1. 부서별 급여합계 등수가 2~3등인 부서번호, 급여합계, 등수를 출력하시오.
SELECT DEPTNO, SUM_SAL, RN
    FROM (SELECT DEPTNO, SUM_SAL, ROWNUM RN
            FROM (SELECT DEPTNO, SUM(SAL) SUM_SAL FROM EMP GROUP BY DEPTNO ORDER BY SUM_SAL DESC))
        WHERE RN BETWEEN 2 AND 3;
-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;
-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT EMPNO, ENAME, HIREDATE
    FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC)
    WHERE ROWNUM<6;
-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT EMPNO, ENAME, HIREDATE
    FROM (SELECT EMPNO, ENAME, HIREDATE, ROWNUM RN 
            FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC))
    WHERE RN BETWEEN 6 AND 10;