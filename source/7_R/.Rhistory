sampleBy(~Species, data=iris, frac=0.1, systematic=T)
#벡터 샘플링
idx <-sample(1:150, 10)
idx
iris[idx,]
# 4. Formula: ~, +, -, :, * 등
## lm() 선형회귀식 도출 함수(독립변수, 종속변수 연속적 변수에서 사용)
x <- c(1,2,3,4,5) #공부 시간(독립변수)
y <- c(20,41,59,81,98) #점수(종속변수) -회귀분석
y1 <- c('F', 'F', 'F', 'P', 'P') #당락여부(종속변수) -로지스틱 회귀; glm()
fit <lm(y~x)
fit <-lm(y~x)
fit
plot(x,y, col='blue')
lines(x, x*19.6+1.0, col='red')
abline(fit, lty='dashed')
# 독립변수가 2개
x1<-c(1,2,3,4,5) #공부시간
x2<-c(10,20,3,4,5) #기출문제 푼 수
y <-c(50, 70, 63, 84, 95) #종속변수
fit <-lm(y~x1+x2) #x1과 x2사이의 상관관계가 없다는 전제 필요
fit
#cars
cars
fit <-lm(cars$dist~cars$speed)
fit <-lm(dist~speed, data=cars)
fit
plot(cars)
plot(cars$speed, cars$dist, col='green')
lines(cars$speed, cars$speed*3.932-17.579, col="blue")
abline(fit, lty="dotted")
# 2021-02-05 R_데이터 전처리_dplyr      ⓒcherryuki(ji) #
# # # 5-1. dplyr 패키지를 이용한 전처리 # # #
# 1. 외부파일 read/write
# 1.1 엑셀파일 읽어오기 readxl 패키지 이용
install.package('readxl')
# 2021-02-05 R_데이터 전처리_dplyr      ⓒcherryuki(ji) #
# # # 5-1. dplyr 패키지를 이용한 전처리 # # #
# 1. 외부파일 read/write
# 1.1 엑셀파일 읽어오기 readxl 패키지 이용
install.packages('readxl')
library(readxl)
library(readxl) #require(readxl)
getwd()
exam <-read_excel("inData/exam.xlsx")
exam <-read_excel("inData/exam.xlsx")
head(exam)
class(exam)
exam <-as.data.frame(exam)
head(exam)
nrow(exam)
exam[21,] <-data.frame(id=21, class=1, math=90, english=80, science=99)
tail(exam)
exam$tot <-exam$math+exam$english+exam$science
mean(exam$tot)
exam$grade <-ifelse(exam$tot>=mean(exam$tot), '상', '하')
table(exam$grade)
apply(exam[,3:6], 2, mean)
#데이터 파일에 컬럼명이 없는 경우
data <-read_excel("inData/data_ex.xls", col_names=FALSE)
data
colnames(data) <-c('id', 'gender', 'age', 'area')
data
# 1.2 데이터 쓰기(파일(csv)로 쓰기 vs. 편수만 쓰기)
write.csv(exam, "outData/exam.csv", row.names = TRUE)
save(exam, file='outData/exam.rda')
rm(list=ls(all.names=TRUE))
load('outData/exam.rda')
exam
# 2. 데이터 파악하기
mpg <-as.data.frame(ggplot2::mpg)
head(mpg)
tail(mpg)
edit(mpg)
View(mpg)
dim(mpg)
str(mpg)
summary(mpg)
# 변수명 바꾸기(cty->city, hwy->highway)
library(dplyr)
mpg <-rename(mpg, city=cty)
mpg <-rename(mpg, highway=hwy)
colnames(mpg)
head(mpg)
# 파생변수 (계산식으로)
mpg$total <-(mpg$city+mpg$highway)/2
head(mpg)
# 파생변수 (조건식으로)
mean(mpg$total)
median(mpg$total)
mpg$test <-ifelse(mpg$total>mean(mpg$total), "pass", "fail")
table(mpg$total)
table(mpg$test) #빈도표 출력
boxplot(mpg$total)
hist(mpg$total)
?qplot
qplot(mpg$test)
library(ggplot2)
qplot(mpg$test)
# 플롯 비교
boxplot(mpg$total)
hist(mpg$total)
install.packages("vioplot")
library(vioplot)
vioplot(mpg$total, col="blue")
par(mfrow=c(1,3)) #시각화 그래프를 1행 3열로 출력
boxplot(mpg$total)
hist(mpg$total)
vioplot(mpg$total, col='green')
par(mfrow=c(1,1)) #플롯 공간 원상복귀
#연습문제
#문제1. 데이터 파악하기
midewest <-as.data.frame(ggplot2::midwest)
#연습문제
#문제1. 데이터 파악하기
midwest <-as.data.frame(ggplot2::midwest)
head(midwest)
rm(midewest)
str(midwest)
summary(midwest)
#문제2. poptotal을 total로, popasian을 asian으로 변수명 수정
head(midwest)
names(midwest)
#문제2. poptotal을 total로, popasian을 asian으로 변수명 수정
midwest <-rename(midwest, c(total=poptotal, asian=popasian))
names(midwest)
colnames(midwest)
#문제3. total, asian 변수를 이용해 "전체 인구 대비 아시아 인구 백분율" 파생변수를 만들고, 히스토그램
midwest$ratio_asian <-(midwest$asian/midwest$total*100)
midwest[1:10, c('total', 'asian', 'ratio_asian')]
hist(midwest$ratio_asian)
boxplot(midwest$ratio_asian)
#문제4. 아시아 인구 백분율 전체 평균
mean(midwest$ratio_asian)
midwest$asian_group <-ifelse(midwest$ratio_asian>mean(midwest$ratio_asian), 'large', 'small')
head(midwest)
dim(midwest)
head(midwest[,c'total', 'asian', 'ratio_asian', 'asian_group'])
head(midwest[,c('total', 'asian', 'ratio_asian', 'asian_group')])
#문제5. large, small 지역 빈도표 확인
table(midwest$asian_group)
qplot(midwest$asian_group)
nrow(midwest)
# 3. 파악한 데이터를 dplyr 패키지를 이용하여 전처리 및 분석하기
#filter(), select(), arrange(), mutate(), summarise(), group_by(), left_join(), bind_rows()
#데이터 변질없이 분석 가능
# 3.1 조건에 맞는 데이터 추출하기: filter() '%>%'의 단축키: ctrl+shift+m
exam <-ream.csv("inData/exam.csv", header=T)
# 3. 파악한 데이터를 dplyr 패키지를 이용하여 전처리 및 분석하기
#filter(), select(), arrange(), mutate(), summarise(), group_by(), left_join(), bind_rows()
#데이터 변질없이 분석 가능
# 3.1 조건에 맞는 데이터 추출하기: filter() '%>%'의 단축키: ctrl+shift+m
exam <-read.csv("inData/exam.csv", header=T)
exam
exam %>%
filter(class==1)
exam %>%
filter(class==1|class==2|class==3)
source('C:/Bigdata/source/7_R/05-1_dplyr패키지를이용한전처리.R', encoding = 'UTF-8', echo=TRUE)
exam %>%
filter(class %in% c(1,2,3))
#class가 1이고 english가 80이상인 데이터 추출
exam %>%
filter(class==1&english>=80)
#class가 1이고 english가 80이상인 데이터 추출
exam1 <- exam %>%
filter(class==1 & english>=80)
#데이터 변질없이 추출 가능. 다시 사용할 예정이라면 변수 등에 저장 필요
exam1
# 3.2 필요한 변수 추출하기: select()
exam %>%
select(class, english, math)
exam %>%
select(-math)
#class가 1과 2의 행 중에서 영어, 수학 데이터만 출력
exam %>%
filter(class %in% c(1,2)) %>%
select(english, math)
# class가 1, 2, 3행에서 영, 수 데이터만 앞 5개 추출
exam %>%
filter(class %in% c(1,2,3) ) %>%
select(english, math) %>%
head(5)
# 3.3 정렬하기: arrange()
exam %>%  arrange(math)
exam %>% arrage(desc(math))
exam %>% arrange(desc(math))
exam %>% arrange(-math)
exam %>% arrange(class, -math)
exam %>% arrange(class, desc(math))
# id가 1부터 10인 학생의 영어, 수학 성적을 영어성적 기준으로 오름차순 정렬하고 top6명만
exam %>%
filter(id %in% c(1:10)) %>%
select(english, math) %>%
arrange(english) %>%
head
## 파생변수 추가: mutate
exam %>%
mutate(total=math+english+science)
head(exam)
exam %>%
mutate(total=math+english+science) %>%
filter(total>=200)
# 파생변수를 한 번에 2개 이상 추가해서 분석
exam %>%
mutate(total=math+english+science,
avg=round(total/3)) %>%
head
#추가한 파생변수는 dplyr 코드에 바로 활용 가능
exam %>%
mutate(total=math+english+science,
avg=round(total/3)) %>%
select(-id) %>%
arrange(desc(total)) %>%
head(3)
# 3.5 요약하기: summarise()
exam %>%
summarise(mean_math=mean(math))
exam %>%
summarise(mean_math=mean(math),
mean_eng=mean(english))
exam %>%
summarise(mean_math=mean(math),
mean_eng=mean(english),
sd_math=sd(math),
sd_eng=sd(english))
# 3.5 집단별로 요약하기: group_by() + summarise()
exam %>%
group_by(class) %>%
summarise(mean_math=mean(math),
n=n(),
max_eng=max(english)) %>%
arrange(mean_math)
# 클래스별 수학, 영어, 과학의 평균
exam %>%
group_by(class) %>%
summarise(mean_math=mean(math),
mean_eng=mean(english),
mean_sci=mean(science))
library(doBy)
summaryBy(math+english+science~class, exam)
#mpg 회사별로 "suv 자동차의 도시 및 고속도로 통합 연비 평균을 구해 내림차순으로 정렬하고 1~5위까지 출력)
mpg <-as.data.frame(ggplot2::mpg)
nrow(mpg)
table(mpg$class)
head(mpg)
mpg %>%
filter(class=='suv') %>%
group_by(manufacturer) %>%
mutate(avg=(cty+hwy)/2) %>%
summarise(avg_manuf=mean(avg)) %>%
arrange(-avg_manuf) %>%
head(5)
#[문제1] 1부터 10사이의 벡터를 만들어서 v1 이라는 변수에 저장한다.
v1 <-c(1:10)
v2 <-v1*2
max_v <-max(v2)
min_v <-min(v2)
avg_v <-mean(v2)
sum_v <-sum(v2)
v3 <-v2(-5)
v3 <-v2[-5]
v3
cat('v1\n',v1,'\nv2\n',v2,'\nv3\n',v3,
'\nmax_v\n',max_v,'\nmin_v\n',min_v,'\navg_v\n',avg_v,'\nsum_v\n',sum_v)
v1; v2; v3; max_v; min_v; avg_v; sum_v;
#[문제2] 10 에서 38사이의 숫자 중에서 2씩 증가한 값으로 벡터를 생성하고
#3행 5열의 매트릭스를 만들어 m1 에 저장한다.(행 우선 저장)
#각 원소 값들에 +100 한 결과로 매트릭스 m2 를 만든다.
m1 <-matrix(seq(10,38,2), nrow =3, ncol=5, byrow=T)
m2 <-m1+100
m2
#[문제2] 10 에서 38사이의 숫자 중에서 2씩 증가한 값으로 벡터를 생성하고
#3행 5열의 매트릭스를 만들어 m1 에 저장한다.(행 우선 저장)
#각 원소 값들에 +100 한 결과로 매트릭스 m2 를 만든다.
m1 <-matrix(c(10:38), nrow=3, byrow = T)
#[문제2] 10 에서 38사이의 숫자 중에서 2씩 증가한 값으로 벡터를 생성하고
#3행 5열의 매트릭스를 만들어 m1 에 저장한다.(행 우선 저장)
#각 원소 값들에 +100 한 결과로 매트릭스 m2 를 만든다.
m1 <-matrix(seq(10,38, 2), nrow=3, byrow = T)
m1
m2 <-m1+100
(m2 <-m1+100)
#[문제3] seq() 또는 rep() 함수를 이용하여 다음 결과가 나오도록 명령을 작성한다.
#(1) 1, 3, 5, 7, 9
seq(1, 9, 2)
#(2) 1, 1, 1, 1, 1
rep(1, 5)
#(3) 1, 2, 3, 1, 2, 3, 1, 2, 3
rep(c(1:3),3)
#(4) 1, 1, 2, 2, 3, 3, 4, 4
rep(c(1:4), each=2)
#[문제4] 1부터 10 까지 출력하는데 3씩 증가 되는 형태로(1 4 7 10)저장되는 벡터를 정의하여
# v3 변수에 저장한다.(또한 각각 값마다 "A", "B", "C", D" 라는 이름을 부여한다.)
v3 <-seq(1,10,3)
v3 <-colnames(c("A", "B", "C", "D"))
v3
#[문제4] 1부터 10 까지 출력하는데 3씩 증가 되는 형태로(1 4 7 10)저장되는 벡터를 정의하여
# v3 변수에 저장한다.(또한 각각 값마다 "A", "B", "C", D" 라는 이름을 부여한다.)
v3 <-seq(1,10,3)
v3
names(v3) <-(c("A", "B", "C", "D"))
v3
names(v3) <-LETTERS(1:4)
names(v3) <-LETTERS[1:4]
v3
#[문제5] 1부터 100으로 구성되는 7개의 중복되지 않는 데이터를 추출하여 count 라는 백터를 만든다.
count <- sample(1:100, 7)
week.korname <- c("일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일")
cat(count, week.korname, sep=':')
cat(paste(count, week.korname, sep=':'))
cat(paste(week.korname, count, sep=':'))
#[문제5] 1부터 100으로 구성되는 7개의 중복되지 않는 데이터를 추출하여 count 라는 백터를 만든다.
count <- sample(1:100, 7)
week.korname <- c("일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일")
cat(paste(week.korname, count, sep=':'))
week.korname(which.max(count))
week.korname[which.max(count)]
week.korname[which.min(count)]
week.korname[count>50]
#[문제6]  다음과 같이 값이 구성되는 매트릭스를 정의하여 m1 에 저장한다.
n1 <-c(1:3)
n2 <-c(7:9)
n2 <-c(4:6)
n3 <-c(7:9)
m1 <-matrix(c(n1,n2,n3), nrow=3)
m1
#[문제7] 다음과 같이 값이 구성되는 매트릭스를 정의하여 m2 에 저장한다.
#1~9 의 벡터를 이용하여 matrix를 생성하고 출력한다.
m2 <- matrix(c(1:9), nrow=3, byrow=T)
#[문제7] 다음과 같이 값이 구성되는 매트릭스를 정의하여 m2 에 저장한다.
#1~9 의 벡터를 이용하여 matrix를 생성하고 출력한다.
(m2 <- matrix(c(1:9), nrow=3, byrow=T))
#[문제8]  m2 를 가지고 다음과 같이 값이 구성되는 매트릭스를 정의하여 m3 에 저장하고 출력한다.
m3 <- matirx(m2, dimnames(c('row1', 'row2', 'row3'), c('col1', 'col2', 'col3')))
#[문제8]  m2 를 가지고 다음과 같이 값이 구성되는 매트릭스를 정의하여 m3 에 저장하고 출력한다.
m3 <- matrix(m2, dimnames(c('row1', 'row2', 'row3'), c('col1', 'col2', 'col3')))
#[문제8]  m2 를 가지고 다음과 같이 값이 구성되는 매트릭스를 정의하여 m3 에 저장하고 출력한다.
m2 <- dimnames(c('row1', 'row2', 'row3'), c('col1', 'col2', 'col3'))
#[문제8]  m2 를 가지고 다음과 같이 값이 구성되는 매트릭스를 정의하여 m3 에 저장하고 출력한다.
m3 <- matrix(m2, nrow=3, ncol=3,
dimnames=list(c('row1', 'row2', 'row3'), c('col1', 'col2', 'col3')))
m3
#[문제9] 다음과 같이 구성 되는 2행 3열 매트릭스 alpha를 생성한 후에
alpha <-matrix(letters[1:6], nrow=2)
alpha
alpha2 <-rbind(letters[24:26])
alpha2
alpha2 <-rbind(alpha, letters[24:26])
alpha2
alpha3 <-cbind(alpha, c('s','p'))
alpha3
(alpha2 <-rbind(alpha, letters[24:26]))
(alpha3 <-cbind(alpha, c('s','p')))
#[문제10] 다음과 같이 값이 구성되는 배열을 정의하여 a 라는 변수에 저장한다.
a <- array(c(1:24), dim=(2,3,4))
#[문제10] 다음과 같이 값이 구성되는 배열을 정의하여 a 라는 변수에 저장한다.
a <- array(c(1:24), dim=c(2,3,4))
a
a[2,3,4]
a[2,,]
a[,1,]
a[,,3]
(a+100)
a[,,4]*100
a[1,2:3,]
a[1,,]
a[1,2:3,]
(a[2,,2] <-a[2,,2]+100)
a
(a[,,1] <-a[,,1]-2)
a <-a*10
a
rm(a)
#[문제11] 다음과 같이 값이 구성되는 데이터프레임을 정의하여 df1 에 저장한다.
df1 <-data.frame(x=(1:5), y=(seq(2,10,2)))
df1
#[문제12] 다음과 같이 값이 구성되는 데이터프레임을 정의하여 df2 에 저장한다.
df2 <- data.frame(col1=1:5, col2=letters[1:5], col3=6:10)
df2
#[문제13] c() 함수로 먼저 벡터를 생성한 다음 data.frame()사용해서
#다음과 같이 구성되는 데이터 프레임 df3를
#만들어 출력해 본다.(제품명이 팩터형이 되지 않게 한다.)
제품명 <-c('사과', '딸기', '수박')
가격 <-c(1800, 1500, 3000)
판매량 <-c(24, 38, 13)
df3 <-data.frame(제품명, 가격, 판매량)
df3
str(df3)
#[문제14] 앞에서 만든 데이터 프레임을 이용해서 과일 가격 평균, 판매량 평균을 구하여 출력한다.
apply(df3[,2:3], mean)
#[문제14] 앞에서 만든 데이터 프레임을 이용해서 과일 가격 평균, 판매량 평균을 구하여 출력한다.
apply(df3[,2:3], 2, mean)
#[문제15] 다음 세 벡터를 이용하여 데이터프레임 df4를 생성하고, name 변수는 문자, gender 변수는 팩터,
#math 변수는 숫자 데이터의 유형이라는 것을 확인하시오.
name <- c('Potter', 'Elsa', 'Gates', 'Wendy', 'Ben')
gender <- factor(c('M', 'F', 'M', 'F', 'M'))
math <- c(85, 76, 99, 88, 40)
df4 <- data.frame(name, gender, math)
str(df4)
class(df4)
is.numeric(math)
stat <- c(76, 73, 95, 82, 35)
df4$stat <-c(76, 73, 95, 82, 35)
df4
df4$score <-df4$math+df4$stat
df4$grade <-ifelse(df4$score>=150, "A", ifelse(df4$score>=100, "B", ifelse(df4$score>=70), "C"))
df4$grade <-ifelse(df4$score>=150, "A", ifelse(df4$score>=100, "B", ifelse(df4$score>=70), "C", NA))
df4$grade <-ifelse(df4$score>=150, "A", ifelse(df4$score>=100, "B", ifelse(df4$score>=70, "C")))
df4
#[문제16] 다음과 같이 값이 구성되는 리스트를 정의하여 L1 에 저장한다.
L1 <-list={name='scott', sal=3000}
#[문제16] 다음과 같이 값이 구성되는 리스트를 정의하여 L1 에 저장한다.
L1 <-list=c('name'='scott', 'sal'=3000)
#[문제16] 다음과 같이 값이 구성되는 리스트를 정의하여 L1 에 저장한다.
L1 <-list(name='scott', sal=3000)
L1
#[문제17] 다음과 같이 값이 구성되는 리스트를 정의하여 L2 에 저장한다.
L2 <-list('scott', c(100, 200, 300))
L2
#[문제18] 다음 리스트에서 A를 "Alpha"로 대체한다.
L3 <-list(c(3,5,7), c('A', 'B', 'C'))
gsub('A', 'Alpha', L3)
L3
L3<- gsub('A', 'Alpha', L3)
L3
L3[2,1] <-Alpha
L3[2,1] <-'Alpha'
L3[[2,1]] <-'Alpha'
L3[[2][1]] <-'Alpha'
L3[[2],[1]] <-'Alpha'
#[문제18] 다음 리스트에서 A를 "Alpha"로 대체한다.
L3 <-list(c(3,5,7), c('A', 'B', 'C'))
L3
L3[[2]][1] <-'Alpha'
L3
#[문제19] 다음 리스트에서 첫 번째 원소(alpha)의 각 값에 10을 더하여 출력한다.
list(alpha=0:4, beta=sqrt(1:5), gamma=log(1:5))
list$alpha+10
list[1]$alpha+10
#[문제19] 다음 리스트에서 첫 번째 원소(alpha)의 각 값에 10을 더하여 출력한다.
L4 <- list(alpha=0:4, beta=sqrt(1:5), gamma=log(1:5))
L4
L4[1]$alpha+10
#[문제20] 다음 리스트는 math, writing, reading의 중간고사 및 기말고사 점수이다.
#전체 평균을 계산하여 출력한다.
L5 <-list(math=list(95, 90), writing=list(90, 85), reading=list(85, 80))
L5
mean(unlist(L5))
#[문제21] iris 데이터에서 다름 기본 정보를 조회한다(기본정보조회)
#타입, 구조, 차원, 변수이름, 기본통계량(평균, 표준편차, 사분위수)
class(iris)
str(iris)
dim(iris)
colnames(iris)
summary(iris)
#[문제22] iris 데이터를 정렬한다
arrange(iris)
#[문제22] iris 데이터를 정렬한다
?orderBy
#[문제22] iris 데이터를 정렬한다
??orderBy
#[문제22] iris 데이터를 정렬한다
library(doBy)
?orderby
??orderby
?orderBy
orderBy(Petal.Length, iris)
orderBy(iris$Petal.Length, iris)
orderBy(~Petal.Length, iris)
orderBy(~-Petal.Length, iris)
iris[order(-Petal.Length)]
iris[order(-iris$Petal.Length)]
iris[order(-iris$Petal.Length),]
#[문제 23] iris 데이터의 종별 데이터 개수 출력한다
table(iris$Species)
#[문제 24] 종별 Sepal.Length의 합을 출력한다.
?tapply
#[문제 24] 종별 Sepal.Length의 합을 출력한다.
tapply(iris$Sepal.Length, iris$Species, FUN=sum)
#[문제 25] Sepal.Length, Sepal.Width, Petal.Length, Petal.Width의 평균을 출력
#(Apply, lappy, sapply이용)
apply(iris$Sepal.Length+iris$Petal.Width+Petal.Length+Petal.Width, mean)
#[문제 25] Sepal.Length, Sepal.Width, Petal.Length, Petal.Width의 평균을 출력
#(Apply, lappy, sapply이용)
apply(iris$Sepal.Length+iris$Petal.Width+Petal.Length+Petal.Width,2, mean)
#[문제 25] Sepal.Length, Sepal.Width, Petal.Length, Petal.Width의 평균을 출력
#(Apply, lappy, sapply이용)
apply(iris$Sepal.Length+iris$Petal.Width+iris$Petal.Length+iris$Petal.Width,2, mean)
#[문제 25] Sepal.Length, Sepal.Width, Petal.Length, Petal.Width의 평균을 출력
#(Apply, lappy, sapply이용)
apply(iris[1:4], 2, mean)
lapply(iris[-5], mean)
sapply(iris[,1:4], mean)
#[문제 25] Sepal.Length, Sepal.Width, Petal.Length, Petal.Width의 평균을 출력
#(Apply, lappy, sapply이용)
apply(iris[,1:4], 2, mean)
lapply(iris[,-5], mean)
sapply(iris[,1:4], mean)
#종별 Sepal.Length의 평균 출력
tapply(iris$Sepal.Length, iris$Species, mean)
summaryBy(~Sepal.Length, Species, iris, mean)
summaryBy(Sepal.Length~Species, iris, mean)
summaryBy(Sepal.Length~Species, iris)
#[문제 26] 꽃받침의 길이(Sepal.Length)가 가장 긴 꽃의 종은 무엇인가요?
which.max(Sepal.Length)
#[문제 26] 꽃받침의 길이(Sepal.Length)가 가장 긴 꽃의 종은 무엇인가요?
which.max(iris$Sepal.Length)
#[문제 26] 꽃받침의 길이(Sepal.Length)가 가장 긴 꽃의 종은 무엇인가요?
iris[which.max(iris$Sepal.Length),5]
iris[which.max(iris$Sepal.Length),'Species']
iris[which.max(iris$Sepal.Length),]$Species
