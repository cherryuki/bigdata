is.primeNum <-function(num) {
if(num<1) {
return(FALSE)
} else {
result <-0
count <-0
for(val in num:1) {
result = num%%val
if(result==0) {
count=count+1
}
}
if(count==2) {
return(TRUE)
} else {
return(FALSE)
}
}
}
is.primeNum(-1)
is.primeNum(0)
is.primeNum(2)
is.primeNum(-3)
is.primeNum(0)
is.primeNum(1)
is.primeNum(2)
is.primeNum(23)
is.primeNum(5)
# 1. 파일 입출력
# 1.1 시스템 인코딩 조회
Sys.getlocale()
# 1.2 write.table(); 데이터를 파일에 저장
iris
class(iris)
write.table(iris, file="outData/iris.csv", sep=",", row.names=FALSE)
InsectSprays
write.table(InsectSprays, file='outData/insect.csv', sep=',')
# 1.3 read.table(); 파일을 읽어 데이터프레임 형태로 저장
irisData <-read.table("outData/iris.csv", sep=',', header=TRUE, encoding='UTF-8', stringsAsFactors = TRUE)
head(irisData)
tail(irisData)
str(irisData)
irisData$Species
irisData$Species <-as.factor(irisData$Species)
irisData$Species <-factor(irisData$Species, levels=c("setosa", "versicolor", "virginica"))
irisData$Species
str(irisData$Species)
nrow(irisData)
summary(irisData)
# 1.4 write.csv(); csv파일 형식으로 저장
write.csv(iris, file="outData/iris1.csv")
write.csv(iris, fiel="outData/iris1.csv", quote=FALSE)
write.csv(iris, file="outData/iris1.csv", quote=FALSE)
# 1.5 read.csv(); csv파일 읽기
newData <-read.csv(file.choose())
newData <-read.csv('outData/iris1.csv', header=TRUE, stringsAsFactors = TRUE)
head(newData)
tail(newData)
str(newData)
summary(newData)
# 1.6 cat(); 분석 결과등을 저장할 때
irisSummary <-summary(newData)
class(irisSummary)
irisSummary[1,]
nrow(irisSummary)
cat('iris 요약:', '\n', file='outData/irisSummary.txt')
for(i in 1:nrow(irisSummary)) {
cat(irisSummary[i,], '\n', file='outData/irisSummary.txt', append=T)
}
# 2. apply계열 함수 적용
# 2.1 apply
#iris데이터의 열별평균(합계, 분산, 표준편차, 최소값, 최대값, 중앙값)
#apply(대상자료, 1or2, 함수) 1:행별 함수 수행, 2: 열별 함수 수행
head(iris[,1:4])
head(iris[,-5])
apply(iris[,1:4],1,mean)
apply(iris[,1:4], 1, mean)
apply(iris[,-5], 2, mean)
#setosa종과 versicolor종과 virginica종을 분류하고 각각의 열별 평균 구하기
apply(subset(iris, iris$Species=='setosa', select=-5), 2, mean)
apply(subset(iris, iris$Species=='versicolor', select=-c(5)),2, mean)
apply(subset(iris, iris$Species=='virginica', select=c(-5)),2, mean)
apply(iris[,1:4], 2, FUN=mean)
apply(iris[,1:4], 2, FUN=sd)
apply(iris[,-5], 2, FUN=sum)
apply(iris[,-5], 2, FUN=median)
apply(iris[,1:4], 2, FUN=min)
apply(iris[,1:4], 2, FUN=max)
apply(iris[,-5], 2, FUN=min)    #열별 최소값
apply(iris[,-5], 2, FUN=max)    #열별 최대값
#InsectSPrays에서 count의 표준 편차
apply(InsectSprays['count'],2, FUN=sd)
#InsectSPrays에서 count의 표준 편차
apply(InsectSprays[,'count'],2, FUN=sd)
#InsectSPrays에서 count의 표준 편차
apply(InsectSprays['count'],2, FUN=sd)
name <-c('김', '이', '박', '강', '윤')
kor <-c(90, 50, 70, 60, 100)
eng <-c(100,40,50,60,70)
mat <-c(90,91,50,64,80)
student <-data.frame(name, kor, eng, mat)
student
apply(studnet[,-1], 1, mean)
apply(student[,-1], 1, mean)
apply(student[,-1], 2, mean)
#2.2 lapply: list apply(결과도 list)
x <- list(a=1:10, beta=exp(-3:3), logical=c(T,F,F,T))
#지수함수: exp(a:b) e의 a승부터 e의 b승까지 출력
x
lapply(x, mean)
lapply(x, quantile)
lapply(x, quantile, 1:3/4)
# 2.3 sapply: lapply와 유사하나 결과를 행렬이나 벡터로 반환
saplly(x, mean)
# 2.3 sapply: lapply와 유사하나 결과를 행렬이나 벡터로 반환
sapply(x, mean)
sapply(x, quantile)
sapply(x, quantile, 1:3/4)
fivenum(0:10)
i39 <-sapply(c(3:9), seq)
i39
sapply(i39, fivenum)
lapply(i39, fivenum)
#Q. iris데이터를 lapply와 sapply를 이용하여 Sepal.Length~Petal.Width까지의 평균
lapply(iris[,-5], mean)
sapply(iris[,-5], mean)
irisList <- as.list(iris[,1:4])
irisList
lapply(irisList, mean)
sapply(irisList, mean)
# 2.4 vapply: sapply와 유사하나 FUN의 모든 값이 FUN.VALUE와 호환되는지 확인
vapply(irisList, mean, numeric(1))
vapply(i39, fivenum,
FUN.VALUE = c(numeric(1), numeric(1), numeric(1), numeric(1), numeric(1)))
cities <-c('Seoul', 'Busan', 'New York', 'Tokyo')
nchar(cities[1])
sapply(cities, nchar)
lapply(cities, nchar)
vapply(cities, ncahr, FUN.VALUE = numeric(1))
vapply(cities, nchar, FUN.VALUE=numeric(1))
# 2.5 mapply: sapply와 유사하나 다수의 인자를 함수에 전달
rep(c(1:3), 3)
x <-c(1,2,3,4)
mean(x)
mapply(rep, x=1:4, times=4:1)
mapply(rep, x=1:4, each=4:1)
rm(list=ls())
#직업별 수입
job <-c(3,3,5,2,2,3,5,3,4,4,6,3)
income <-c(4897,6509,4183,0,3894,0,3611,6454,4975,8780,0,4362)
cust <-data.frame(job, income)
cust
income.avg <-c(862, 0, 3806, 3990, 3891, 3359, 3556, 2199)
names(income.avg) <-0:7
income.avg
zero2mean <-function(job, income) {
#return(ifelse(income==0, income.avg[as.character(job)], income))
if(income==0) {
return(income.avg[as.character(job)])
}else {
return(income)
}
}
#mapply(zero2mean, cust$job, cust$income)
cust$income2 <- mapply(zero2mean, cust$job, cust$income)
cust
# 3. 데이터 그룹화 함수 적용
# 3.1 tapply: 그룹별 처리를 위한 apply함수
tapply(iris$Sepal.Length, iris$Species, mean)
tapply(iris$Sepal.Length, iris$Species, sd)
boxplot(iris$Sepal.Length~iris$Species)
cust
#직업별
cust$job <-factor(cust$job, levels=0:7)
str(cust)
tapply(cust$income2, cust$job, mean)
tapply(cust$income2, cust$job, FUN=mean, default = -1)
datasets::InsectSprays
head(InsectSprays)
tail(InsectSprays)
str(InsectSprays)
# spray의 종류에 따른 살충효과를 점검
tapply(InsectSprays$count, InsectSprays$spray, mean)
nrow(InsectSprays)
tapply(InsectSprays$count, InsectSprays$spray, sd)
boxplot(InsectSprays$count~InsectSprays$spray)
# 3.2 by: 그룹화 처리를 위한 apply(함수 2개 이상 가능)
by(iris[,1:2], iris[,5] sum)
# 3.2 by: 그룹화 처리를 위한 apply(함수 2개 이상 가능)
by(iris[,1:2], iris[,5], sum)
by(iris[,1:2], iris[,5], min)
by(iris[,1:4], iris$Species, summary)
#cust의 직업별 평균을 income과 income2 한번에
by(cust[,c('income', 'income2')], cust$job, mean)
#cust의 직업별 평균을 income과 income2 한번에
by(cust[,c('income', 'income2')], cust$job, summary)
#cust의 직업별 평균을 income과 income2 한번에 #mean은 불가능
by(cust[,c('income', 'income2')], cust$job, FUN=mean)
#cust의 직업별 평균을 income과 income2 한번에 #mean은 불가능
by(cust[,c('income', 'income2')], cust$job, summary)
# 3.3 doBy 패키지
install.packages('doBy')
library(doBy)
summaryBy(Sepal.Length+Sepal.Width~Species, iris)
summaryBy(Sepal.Length+Sepal.Width+Petal.Length+Petal.Width~Species, iris, FUN=sd)
summaryBy(Sepal.Length+Sepal.Width+Petal.Length+Petal.Width~Species,
iris, FUN=c(mean, sd))
summaryBy(Sepal.Length+Sepal.Width+Petal.Length+Petal.Width~Species,
iris, FUN=c(mean, sd))
#Q. emp.csv 파일의 데이터를 받아 부서별 급여, 상여금을 비교
emp <-read.csv(file="inData/emp.csv", header=T)
emp
str(emp)
emp$deptno <-factor(emp$deptno, levels=seq(10,40,10))
names(emp)
taaply(emp$comm, emp$deptno, FUN=mean)
tapply(emp$sal, emp$deptno, FUN=mean, default=0)
tapply(emp$sal, emp$deptno, FUN=mean)
tapply(emp$comm, emp$deptno, FUN=mean)
summaryBy(sal+comm~deptno, emp, FUN=mean, na.rm=T)
tapply(emp$comm, emp$deptno, FUN=mean, na.rm=T)
# (2) orderBy 정렬
orderBy(~Sepal.Length, data=iris)
orderBy(~-Sepal.Length, data=iris)
orderBy(~Species+Sepal.Length, data=iris)
orderBy(~Species-Sepal.Length, data=iris) #Species, Sepal.Length 내림림차순
#종별, Sepal.Length 오름차순으로 정렬한 데이터
orderBy(~Species+Sepal.Length, data=iris[, c('Sepal.Length', 'Sepal.Width', 'Species')])
head(orderBy(~Species+Sepal.Length, data=iris))
#Q1. emp데이터셋에서 월급이 적은 순으로 ename, sal 추출
orderBy(~emp$sal, data=emp)
#Q1. emp데이터셋에서 월급이 적은 순으로 ename, sal 추출
orderBy(~sal, data=emp)
#Q1. emp데이터셋에서 월급이 적은 순으로 ename, sal 추출
orderBy(~sal, data=emp[,c('ename', 'sal')])
#Q2. 월급이 적은 순 5명만 ename, sal
head(orderBy(~sal, data=emp[,c('ename', 'sal')]),5)
# (3) sampleBy
sampleBy(~Species, data=iris, frac=0.1)
sampleBy(~Species, data=iris, frac=0.1, replace=T)
sampleBy(~Species, data=iris, frac=0.1, systematic=T)
#벡터 샘플링
idx <-sample(1:150, 10)
idx
iris[idx,]
# 4. Formula: ~, +, -, :, * 등
## lm() 선형회귀식 도출 함수(독립변수, 종속변수 연속적 변수에서 사용)
x <- c(1,2,3,4,5) #공부 시간(독립변수)
y <- c(20,41,59,81,98) #점수(종속변수) -회귀분석
y1 <- c('F', 'F', 'F', 'P', 'P') #당락여부(종속변수) -로지스틱 회귀; glm()
fit <lm(y~x)
fit <-lm(y~x)
fit
plot(x,y, col='blue')
lines(x, x*19.6+1.0, col='red')
abline(fit, lty='dashed')
# 독립변수가 2개
x1<-c(1,2,3,4,5) #공부시간
x2<-c(10,20,3,4,5) #기출문제 푼 수
y <-c(50, 70, 63, 84, 95) #종속변수
fit <-lm(y~x1+x2) #x1과 x2사이의 상관관계가 없다는 전제 필요
fit
#cars
cars
fit <-lm(cars$dist~cars$speed)
fit <-lm(dist~speed, data=cars)
fit
plot(cars)
plot(cars$speed, cars$dist, col='green')
lines(cars$speed, cars$speed*3.932-17.579, col="blue")
abline(fit, lty="dotted")
# 2021-02-05 R_데이터 전처리_dplyr      ⓒcherryuki(ji) #
# # # 5-1. dplyr 패키지를 이용한 전처리 # # #
# 1. 외부파일 read/write
# 1.1 엑셀파일 읽어오기 readxl 패키지 이용
install.package('readxl')
# 2021-02-05 R_데이터 전처리_dplyr      ⓒcherryuki(ji) #
# # # 5-1. dplyr 패키지를 이용한 전처리 # # #
# 1. 외부파일 read/write
# 1.1 엑셀파일 읽어오기 readxl 패키지 이용
install.packages('readxl')
library(readxl)
library(readxl) #require(readxl)
getwd()
exam <-read_excel("inData/exam.xlsx")
exam <-read_excel("inData/exam.xlsx")
head(exam)
class(exam)
exam <-as.data.frame(exam)
head(exam)
nrow(exam)
exam[21,] <-data.frame(id=21, class=1, math=90, english=80, science=99)
tail(exam)
exam$tot <-exam$math+exam$english+exam$science
mean(exam$tot)
exam$grade <-ifelse(exam$tot>=mean(exam$tot), '상', '하')
table(exam$grade)
apply(exam[,3:6], 2, mean)
#데이터 파일에 컬럼명이 없는 경우
data <-read_excel("inData/data_ex.xls", col_names=FALSE)
data
colnames(data) <-c('id', 'gender', 'age', 'area')
data
# 1.2 데이터 쓰기(파일(csv)로 쓰기 vs. 편수만 쓰기)
write.csv(exam, "outData/exam.csv", row.names = TRUE)
save(exam, file='outData/exam.rda')
rm(list=ls(all.names=TRUE))
load('outData/exam.rda')
exam
# 2. 데이터 파악하기
mpg <-as.data.frame(ggplot2::mpg)
head(mpg)
tail(mpg)
edit(mpg)
View(mpg)
dim(mpg)
str(mpg)
summary(mpg)
# 변수명 바꾸기(cty->city, hwy->highway)
library(dplyr)
mpg <-rename(mpg, city=cty)
mpg <-rename(mpg, highway=hwy)
colnames(mpg)
head(mpg)
# 파생변수 (계산식으로)
mpg$total <-(mpg$city+mpg$highway)/2
head(mpg)
# 파생변수 (조건식으로)
mean(mpg$total)
median(mpg$total)
mpg$test <-ifelse(mpg$total>mean(mpg$total), "pass", "fail")
table(mpg$total)
table(mpg$test) #빈도표 출력
boxplot(mpg$total)
hist(mpg$total)
?qplot
qplot(mpg$test)
library(ggplot2)
qplot(mpg$test)
# 플롯 비교
boxplot(mpg$total)
hist(mpg$total)
install.packages("vioplot")
library(vioplot)
vioplot(mpg$total, col="blue")
par(mfrow=c(1,3)) #시각화 그래프를 1행 3열로 출력
boxplot(mpg$total)
hist(mpg$total)
vioplot(mpg$total, col='green')
par(mfrow=c(1,1)) #플롯 공간 원상복귀
#연습문제
#문제1. 데이터 파악하기
midewest <-as.data.frame(ggplot2::midwest)
#연습문제
#문제1. 데이터 파악하기
midwest <-as.data.frame(ggplot2::midwest)
head(midwest)
rm(midewest)
str(midwest)
summary(midwest)
#문제2. poptotal을 total로, popasian을 asian으로 변수명 수정
head(midwest)
names(midwest)
#문제2. poptotal을 total로, popasian을 asian으로 변수명 수정
midwest <-rename(midwest, c(total=poptotal, asian=popasian))
names(midwest)
colnames(midwest)
#문제3. total, asian 변수를 이용해 "전체 인구 대비 아시아 인구 백분율" 파생변수를 만들고, 히스토그램
midwest$ratio_asian <-(midwest$asian/midwest$total*100)
midwest[1:10, c('total', 'asian', 'ratio_asian')]
hist(midwest$ratio_asian)
boxplot(midwest$ratio_asian)
#문제4. 아시아 인구 백분율 전체 평균
mean(midwest$ratio_asian)
midwest$asian_group <-ifelse(midwest$ratio_asian>mean(midwest$ratio_asian), 'large', 'small')
head(midwest)
dim(midwest)
head(midwest[,c'total', 'asian', 'ratio_asian', 'asian_group'])
head(midwest[,c('total', 'asian', 'ratio_asian', 'asian_group')])
#문제5. large, small 지역 빈도표 확인
table(midwest$asian_group)
qplot(midwest$asian_group)
nrow(midwest)
# 3. 파악한 데이터를 dplyr 패키지를 이용하여 전처리 및 분석하기
#filter(), select(), arrange(), mutate(), summarise(), group_by(), left_join(), bind_rows()
#데이터 변질없이 분석 가능
# 3.1 조건에 맞는 데이터 추출하기: filter() '%>%'의 단축키: ctrl+shift+m
exam <-ream.csv("inData/exam.csv", header=T)
# 3. 파악한 데이터를 dplyr 패키지를 이용하여 전처리 및 분석하기
#filter(), select(), arrange(), mutate(), summarise(), group_by(), left_join(), bind_rows()
#데이터 변질없이 분석 가능
# 3.1 조건에 맞는 데이터 추출하기: filter() '%>%'의 단축키: ctrl+shift+m
exam <-read.csv("inData/exam.csv", header=T)
exam
exam %>%
filter(class==1)
exam %>%
filter(class==1|class==2|class==3)
source('C:/Bigdata/source/7_R/05-1_dplyr패키지를이용한전처리.R', encoding = 'UTF-8', echo=TRUE)
exam %>%
filter(class %in% c(1,2,3))
#class가 1이고 english가 80이상인 데이터 추출
exam %>%
filter(class==1&english>=80)
#class가 1이고 english가 80이상인 데이터 추출
exam1 <- exam %>%
filter(class==1 & english>=80)
#데이터 변질없이 추출 가능. 다시 사용할 예정이라면 변수 등에 저장 필요
exam1
# 3.2 필요한 변수 추출하기: select()
exam %>%
select(class, english, math)
exam %>%
select(-math)
#class가 1과 2의 행 중에서 영어, 수학 데이터만 출력
exam %>%
filter(class %in% c(1,2)) %>%
select(english, math)
# class가 1, 2, 3행에서 영, 수 데이터만 앞 5개 추출
exam %>%
filter(class %in% c(1,2,3) ) %>%
select(english, math) %>%
head(5)
# 3.3 정렬하기: arrange()
exam %>%  arrange(math)
exam %>% arrage(desc(math))
exam %>% arrange(desc(math))
exam %>% arrange(-math)
exam %>% arrange(class, -math)
exam %>% arrange(class, desc(math))
# id가 1부터 10인 학생의 영어, 수학 성적을 영어성적 기준으로 오름차순 정렬하고 top6명만
exam %>%
filter(id %in% c(1:10)) %>%
select(english, math) %>%
arrange(english) %>%
head
## 파생변수 추가: mutate
exam %>%
mutate(total=math+english+science)
head(exam)
exam %>%
mutate(total=math+english+science) %>%
filter(total>=200)
# 파생변수를 한 번에 2개 이상 추가해서 분석
exam %>%
mutate(total=math+english+science,
avg=round(total/3)) %>%
head
#추가한 파생변수는 dplyr 코드에 바로 활용 가능
exam %>%
mutate(total=math+english+science,
avg=round(total/3)) %>%
select(-id) %>%
arrange(desc(total)) %>%
head(3)
# 3.5 요약하기: summarise()
exam %>%
summarise(mean_math=mean(math))
exam %>%
summarise(mean_math=mean(math),
mean_eng=mean(english))
exam %>%
summarise(mean_math=mean(math),
mean_eng=mean(english),
sd_math=sd(math),
sd_eng=sd(english))
# 3.5 집단별로 요약하기: group_by() + summarise()
exam %>%
group_by(class) %>%
summarise(mean_math=mean(math),
n=n(),
max_eng=max(english)) %>%
arrange(mean_math)
# 클래스별 수학, 영어, 과학의 평균
exam %>%
group_by(class) %>%
summarise(mean_math=mean(math),
mean_eng=mean(english),
mean_sci=mean(science))
library(doBy)
summaryBy(math+english+science~class, exam)
#mpg 회사별로 "suv 자동차의 도시 및 고속도로 통합 연비 평균을 구해 내림차순으로 정렬하고 1~5위까지 출력)
mpg <-as.data.frame(ggplot2::mpg)
nrow(mpg)
table(mpg$class)
head(mpg)
mpg %>%
filter(class=='suv') %>%
group_by(manufacturer) %>%
mutate(avg=(cty+hwy)/2) %>%
summarise(avg_manuf=mean(avg)) %>%
arrange(-avg_manuf) %>%
head(5)
#[문제1] 1부터 10사이의 벡터를 만들어서 v1 이라는 변수에 저장한다.
v1 <-c(1:10)
v2 <-v1*2
max_v <-max(v2)
min_v <-min(v2)
avg_v <-mean(v2)
sum_v <-sum(v2)
v3 <-v2(-5)
v3 <-v2[-5]
v3
cat('v1\n',v1,'\nv2\n',v2,'\nv3\n',v3,
'\nmax_v\n',max_v,'\nmin_v\n',min_v,'\navg_v\n',avg_v,'\nsum_v\n',sum_v)
v1; v2; v3; max_v; min_v; avg_v; sum_v;
#[문제2] 10 에서 38사이의 숫자 중에서 2씩 증가한 값으로 벡터를 생성하고
#3행 5열의 매트릭스를 만들어 m1 에 저장한다.(행 우선 저장)
#각 원소 값들에 +100 한 결과로 매트릭스 m2 를 만든다.
m1 <-matrix(seq(10,38,2), nrow =3, ncol=5, byrow=T)
m2 <-m1+100
m2
